export declare const ContractDeployTmpl = "\n\"use strict\"\n\n// import required libs\nconst fs = require('fs');\nconst Web3 = require(\"@artela/web3\");\nvar argv = require('yargs')\n    .string('node')\n    .string('pkfile')\n    .string('bytecode')\n    .string('abi')\n    .string('gas')\n    .string('args')\n    .argv;\n\n\nasync function deploy() {\n\n    const configJson = JSON.parse(fs.readFileSync('./project.config.json', \"utf-8\").toString());\n    // init connection to Artela node\n    let node = (argv.node) ? String(argv.node) : configJson.node;\n    if (!node) {\n        console.log(\"'node' cannot be empty, please set by the parameter or artela.config.json\")\n        process.exit(0)\n    }\n    const web3 = new Web3(node);\n\n    const deployParams = {\n        data: null,\n        arguments: null,\n    }\n    // get bytecode by path  --bytecode  ./build/contract/xxx.bin\n    let bytecodePath = String(argv.bytecode)\n    let byteTxt = \"\"\n    if (!bytecodePath) {\n        console.log(\"'bytecode' cannot be empty, please set by the parameter ' --bytecode ./build/contract/xxx.bin'\")\n        process.exit(0)\n    } else {\n        byteTxt = fs.readFileSync(bytecodePath, \"utf-8\").toString().trim();\n        if (!byteTxt) {\n            console.log(\"bytecode cannot be empty\")\n            process.exit(0)\n        }\n        if (byteTxt.startsWith(\"0x\")) {\n            byteTxt = byteTxt.slice(2);\n        }\n        deployParams.data = byteTxt.trim()\n    }\n    // --args [55]\n    const inputs = argv.args;\n    if (inputs && inputs !== 'undefined') {\n        deployParams.arguments = JSON.parse(inputs)\n    }\n\n    //--abi ./build/contract/xxx.abi\n    let abiPath = String(argv.abi)\n    let abiTxt = \"\"\n    if (!abiPath) {\n        console.log(\"'abi' cannot be empty, please set by the parameter ' --abi ./build/contract/xxx.abi'\")\n        process.exit(0)\n    } else {\n        abiTxt = fs.readFileSync(abiPath, \"utf-8\").toString().trim();\n        if (!abiTxt) {\n            console.log(\"'abi' json cannot be empty\")\n            process.exit(0)\n        }\n    }\n\n    //--pkfile ./build/privateKey.txt\n    let senderPriKey = String(argv.pkfile)\n    if (!senderPriKey || senderPriKey === 'undefined') {\n        senderPriKey = \"privateKey.txt\"\n    }\n    if (!fs.existsSync(senderPriKey)) {\n        console.log(\"'account' cannot be empty, please set by the parameter ' --pkfile ./build/privateKey.txt'\")\n        process.exit(0)\n    }\n    let pk = fs.readFileSync(senderPriKey, 'utf-8');\n    let account = web3.eth.accounts.privateKeyToAccount(pk.trim());\n    console.log(\"from address: \", account.address);\n    web3.eth.accounts.wallet.add(account.privateKey);\n\n\n    // deploy demo contract\n    let contractAddress;\n    {\n        const contractAbi = JSON.parse(abiTxt);\n\n        // instantiate an instance of demo contract\n        let tokenContract = new web3.eth.Contract(contractAbi);\n\n        // deploy token contract\n        let tokenDeploy = tokenContract.deploy(deployParams);\n        let nonceVal = await web3.eth.getTransactionCount(account.address);\n\n        let tokenTx = {\n            from: account.address,\n            data: tokenDeploy.encodeABI(),\n            nonce: nonceVal,\n            gas: !parseInt(argv.gas) | 7000000\n        }\n\n\n        let signedTokenTx = await web3.eth.accounts.signTransaction(tokenTx, account.privateKey);\n        console.log('deploy contract tx hash: ' + signedTokenTx.transactionHash);\n        await web3.eth.sendSignedTransaction(signedTokenTx.rawTransaction)\n            .on('receipt', receipt => {\n                console.log(receipt);\n                console.log(\"contract address: \", receipt.contractAddress);\n                contractAddress = receipt.contractAddress;\n            });\n    }\n    console.log(`--contractAccount ${account.address} --contractAddress ${contractAddress}`);\n\n}\n\ndeploy().then();\n\n";
