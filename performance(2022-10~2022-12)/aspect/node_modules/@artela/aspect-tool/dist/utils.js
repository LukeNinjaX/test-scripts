"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getParamPrefix = exports.ASTStruct = exports.ASTMapping = exports.ASTArray = exports.ASTString = exports.ASTBytesN = exports.ASTBytes = exports.ASTAddress = exports.ASTBoolean = exports.ASTNumber = exports.getMapFirstParam = exports.getMapSecondParam = exports.getStrBetLastCommaAndParen = exports.getStrAfterLastColon = exports.getStrBetweenColon = exports.isStringEmpty = void 0;
function isStringEmpty(str) {
    return !str.trim();
}
exports.isStringEmpty = isStringEmpty;
function getStrBetweenColon(str) {
    const startIndex = str.indexOf('(');
    const endIndex = str.indexOf(')');
    if (startIndex === -1 || endIndex === -1 || startIndex >= endIndex) {
        return '';
    }
    return str.substring(startIndex + 1, endIndex);
}
exports.getStrBetweenColon = getStrBetweenColon;
function getStrAfterLastColon(input) {
    const lastColonIndex = input.lastIndexOf(':');
    if (lastColonIndex === -1) {
        return input;
    }
    return input.slice(lastColonIndex + 1).trim();
}
exports.getStrAfterLastColon = getStrAfterLastColon;
function getStrBetLastCommaAndParen(input) {
    if (!input.startsWith('t_mapping')) {
        return input;
    }
    const lastCommaIndex = input.lastIndexOf(',');
    const lastParenthesisIndex = input.lastIndexOf(')');
    if (lastCommaIndex === -1 ||
        lastParenthesisIndex === -1 ||
        lastCommaIndex >= lastParenthesisIndex) {
        return '';
    }
    return input.slice(lastCommaIndex + 1, lastParenthesisIndex).trim();
}
exports.getStrBetLastCommaAndParen = getStrBetLastCommaAndParen;
function getMapSecondParam(input) {
    if (!input.startsWith('t_mapping')) {
        return input;
    }
    const i = input.indexOf(',');
    const j = input.lastIndexOf(')');
    if (i === -1 || j === -1 || i >= j) {
        return '';
    }
    return input.slice(i + 1, j).trim();
}
exports.getMapSecondParam = getMapSecondParam;
function getMapFirstParam(input) {
    if (!input.startsWith('t_mapping')) {
        return input;
    }
    const i = input.lastIndexOf('(');
    const j = input.lastIndexOf(',');
    if (i === -1 || j === -1 || i >= j) {
        return '';
    }
    return input.slice(i + 1, j).trim();
}
exports.getMapFirstParam = getMapFirstParam;
var ASTTypeId;
(function (ASTTypeId) {
    ASTTypeId[ASTTypeId["Number"] = 0] = "Number";
    ASTTypeId[ASTTypeId["BytesN"] = 1] = "BytesN";
    ASTTypeId[ASTTypeId["Address"] = 2] = "Address";
    ASTTypeId[ASTTypeId["Boolean"] = 3] = "Boolean";
    ASTTypeId[ASTTypeId["Array"] = 4] = "Array";
    ASTTypeId[ASTTypeId["Mapping"] = 5] = "Mapping";
    ASTTypeId[ASTTypeId["Tuple"] = 6] = "Tuple";
    ASTTypeId[ASTTypeId["Bytes"] = 7] = "Bytes";
    ASTTypeId[ASTTypeId["String"] = 8] = "String";
})(ASTTypeId || (ASTTypeId = {}));
class BaseType {
    isComplexType() {
        const typeId = this.typeId();
        return typeId == ASTTypeId.Mapping || typeId == ASTTypeId.Array || typeId == ASTTypeId.Tuple;
    }
    asType() {
        return '';
    }
    getClassName(prefix) {
        return prefix;
    }
    constructorFunc(stateVarName) {
        return `
        constructor(ctx: TraceCtx, addr: string, indices: Uint8Array[] = []) {
            super(new StateChangeProperties(ctx, addr, '${stateVarName}', indices));
        }
        `;
    }
    classDef(prefix) {
        return ('export class ' +
            this.getClassName(prefix) +
            ' extends StateChange<' +
            this.asType() +
            '> {\n');
    }
    generateClass(prefix, stateVarName) {
        let res = '';
        res += this.classDef(prefix);
        res += this.constructorFunc(stateVarName);
        res += this.unmarshalStateFunc();
        res += '}\n';
        return res;
    }
}
class BaseComplexType extends BaseType {
    unmarshalStateFunc() {
        return '';
    }
    getClassName(prefix) {
        return prefix;
    }
    classDef(prefix) {
        return ('export class ' + this.getClassName(prefix) + ' extends StateKey<' + this.asType() + '> {\n');
    }
}
class ASTNumber extends BaseType {
    constructor(bits, signed = false) {
        super();
        this.bits = bits;
        this.signed = signed;
        if (bits % 8 != 0) {
            throw new Error('number bits must be multiple of 8');
        }
    }
    typeId() {
        return ASTTypeId.Number;
    }
    asType() {
        if (this.bits <= 64) {
            if (this.signed) {
                return 'i' + this.bits;
            }
            return 'u' + this.bits;
        }
        return 'BigInt';
    }
    unmarshalStateFunc() {
        if (this.bits > 64) {
            return `
            override unmarshalState(raw: EthStateChange) : State<BigInt> {
                let valueHex = sys.utils.uint8ArrayToHex(raw.value);
                let value = BigInt.fromString(valueHex, 16);
                return new State(raw.account, value, raw.callIndex);
            }
        `;
        }
        return `
        override unmarshalState(raw: EthStateChange) : State<${this.asType()}> {
            let valueHex = sys.utils.uint8ArrayToHex(raw.value);
            let value = BigInt.fromString(valueHex, 16);
            return new State(raw.account, <${this.asType()}>value.to${this.signed ? 'U' : ''}Int64(), raw.callIndex);
        }
        `;
    }
    parseKeyFunc() {
        if (this.bits <= 64) {
            return `
                protected parseKey(key: ${this.asType()}): Uint8Array {
                    return ethereum.Number.from${this.asType().toUpperCase()}(key).encodeUint8Array();
                }
            `;
        }
        return `
            protected parseKey(key: ${this.asType()}): Uint8Array {
                return ethereum.Number.fromHexString(key.toString(16), ${this.signed}).encodeUint8Array();
            }
        `;
    }
}
exports.ASTNumber = ASTNumber;
class ASTBoolean extends BaseType {
    asType() {
        return 'bool';
    }
    typeId() {
        return ASTTypeId.Boolean;
    }
    unmarshalStateFunc() {
        return `
        override unmarshalState(raw: EthStateChange) : State<${this.asType()}> {
            return new State(raw.account, raw.value[0] > 0, raw.callIndex);
        }
        `;
    }
    parseKeyFunc() {
        return `
            protected parseKey(key: ${this.asType()}): Uint8Array {
                return ethereum.Boolean.fromBoolean(key).encodeUint8Array();
            }
        `;
    }
}
exports.ASTBoolean = ASTBoolean;
class ASTAddress extends BaseType {
    asType() {
        return 'string';
    }
    typeId() {
        return ASTTypeId.Address;
    }
    unmarshalStateFunc() {
        return `
        override unmarshalState(raw: EthStateChange) : State<${this.asType()}> {
            return new State(raw.account, sys.utils.uint8ArrayToHex(raw.value), raw.callIndex);
        }
        `;
    }
    parseKeyFunc() {
        return `
            protected parseKey(key: ${this.asType()}): Uint8Array {
                return ethereum.Address.fromHexString(key).encodeUint8Array();
            }
        `;
    }
}
exports.ASTAddress = ASTAddress;
class ASTBytes extends BaseType {
    asType() {
        return 'Uint8Array';
    }
    typeId() {
        return ASTTypeId.Bytes;
    }
    unmarshalStateFunc() {
        return `
        override unmarshalState(raw: EthStateChange) : State<${this.asType()}> {
            return new State(raw.account, raw.value, raw.callIndex);
        }
        `;
    }
    parseKeyFunc() {
        return `
            protected parseKey(key: ${this.asType()}): Uint8Array {
                return key;
            }
        `;
    }
}
exports.ASTBytes = ASTBytes;
class ASTBytesN extends ASTBytes {
    typeId() {
        return ASTTypeId.BytesN;
    }
    asType() {
        return 'string';
    }
    parseKeyFunc() {
        return `
            protected parseKey(key: ${this.asType()}): Uint8Array {
                return ethereum.BytesN.fromHexString(key).encodeUint8Array();
            }
        `;
    }
}
exports.ASTBytesN = ASTBytesN;
class ASTString extends BaseType {
    asType() {
        return 'string';
    }
    typeId() {
        return ASTTypeId.String;
    }
    unmarshalStateFunc() {
        return `
        override unmarshalState(raw: EthStateChange) : State<${this.asType()}> {
            return new State(raw.account, sys.utils.uint8ArrayToString(raw.value), raw.callIndex);
        }
        `;
    }
    parseKeyFunc() {
        return `
            protected parseKey(key: ${this.asType()}): Uint8Array {
                return sys.utils.stringToUint8Array(key);
            }
        `;
    }
}
exports.ASTString = ASTString;
class ASTArray extends BaseComplexType {
    constructor(elemType) {
        super();
        this.elemType = elemType;
    }
    asType() {
        return 'u64';
    }
    typeId() {
        return ASTTypeId.Array;
    }
    accessOperator(childClass) {
        return `
            @operator("[]")
            get(index: u64): ${childClass} {
                return new ${childClass}(this.__properties__.ctx, this.__properties__.account, 
                                         sys.utils.arrayCopyPush(this.__properties__.indices, this.parseKey(index)));
            }
        `;
    }
    parseKeyFunc() {
        return `
        protected parseKey(key: u64): Uint8Array {
            return ethereum.Number.fromU64(key).encodeUint8Array();
        }
        `;
    }
    indexValue() {
        return `childrenIndexValue(index: u64): ethereum.Number {
      return ethereum.Number.fromUint8Array(this.__children__[index]);
    }`;
    }
    indexAccess(childClass) {
        return `
            childChangeAt(index: u64): ${childClass} {
                // @ts-ignore
                return new ${childClass}(this.__properties__.ctx, this.__properties__.account, 
                                         sys.utils.arrayCopyPush(this.__properties__.indices, this.__children__[index]));
            }
        `;
    }
    generateClass(prefix, stateVarName) {
        let res = '';
        const childClassName = this.elemType.getClassName(prefix + '_ArrayElement');
        res += this.elemType.generateClass(childClassName, stateVarName);
        res += this.classDef(prefix);
        res += this.constructorFunc(stateVarName);
        res += this.accessOperator(childClassName);
        res += this.parseKeyFunc();
        res += this.indexValue();
        res += this.indexAccess(childClassName);
        res += '}\n';
        return res;
    }
}
exports.ASTArray = ASTArray;
class ASTMapping extends BaseComplexType {
    constructor(keyType, valueType) {
        super();
        this.keyType = keyType;
        this.valueType = valueType;
    }
    asType() {
        return this.keyType.asType();
    }
    typeId() {
        return ASTTypeId.Mapping;
    }
    accessOperator(childClass) {
        return `
            @operator("[]")
            get(key: ${this.asType()}): ${childClass} {
                // @ts-ignore
                return new ${childClass}(this.__properties__.ctx, this.__properties__.account, 
                                         sys.utils.arrayCopyPush(this.__properties__.indices, this.parseKey(key)));
            }
        `;
    }
    indexAccess(childClass) {
        return `
            childChangeAt(index: u64): ${childClass} {
                // @ts-ignore
                return new ${childClass}(this.__properties__.ctx, this.__properties__.account, 
                                         sys.utils.arrayCopyPush(this.__properties__.indices, this.__children__[index]));
            }
        `;
    }
    indexValue() {
        switch (this.keyType.typeId()) {
            case ASTTypeId.Number:
                return `childrenIndexValue(index: u64): ethereum.Number {
          return ethereum.Number.fromUint8Array(this.__children__[index]);
        }`;
            case ASTTypeId.BytesN:
                return `childrenIndexValue(index: u64): ethereum.BytesN {
          return ethereum.BytesN.fromUint8Array(this.__children__[index]);
        }`;
            case ASTTypeId.Address:
                return `childrenIndexValue(index: u64): ethereum.Address {
          return ethereum.Address.fromUint8Array(this.__children__[index]);
        }`;
            case ASTTypeId.Boolean:
                return `childrenIndexValue(index: u64): ethereum.Boolean {
          return ethereum.Boolean.fromUint8Array(this.__children__[index]);
        }`;
            case ASTTypeId.Bytes:
                return `childrenIndexValue(index: u64): ethereum.Bytes {
          return ethereum.Bytes.fromUint8Array(this.__children__[index]);
        }`;
            case ASTTypeId.String:
                return `childrenIndexValue(index: u64): ethereum.String {
          return ethereum.String.fromUint8Array(this.__children__[index]);
        }`;
            default:
                throw new Error('invalid mapping key type');
        }
    }
    parseKeyFunc() {
        return this.keyType.parseKeyFunc();
    }
    generateClass(prefix, stateVarName) {
        let res = '';
        const valueClass = this.valueType.getClassName(prefix + '_MappingValue');
        res += this.valueType.generateClass(valueClass, stateVarName);
        res += this.classDef(prefix);
        res += this.constructorFunc(stateVarName);
        res += this.accessOperator(valueClass);
        res += this.parseKeyFunc();
        res += this.indexValue();
        res += this.indexAccess(valueClass);
        res += '}\n';
        return res;
    }
}
exports.ASTMapping = ASTMapping;
class ASTStruct extends BaseComplexType {
    constructor(members) {
        super();
        this.members = members;
    }
    asType() {
        return 'void';
    }
    typeId() {
        return ASTTypeId.Tuple;
    }
    generateProperties(propertyClasses) {
        let res = '';
        for (let i = 0; i < this.members.length; i++) {
            res += `
            public readonly ${this.members[i][0]}: ${propertyClasses[i]};
            `;
        }
        return res;
    }
    structConstructor(stateVarName, properties) {
        let res = `
        constructor(ctx: TraceCtx, addr: string, indices: Uint8Array[] = []) {
        `;
        for (let i = 0; i < properties.length; i++) {
            res += `
            this.${properties[i][0]} = new ${properties[i][1]}(ctx, addr,
             sys.utils.arrayCopyPush(indices, sys.utils.stringToUint8Array('${properties[i][0]}')));
            `;
        }
        return res + '}\n';
    }
    classDef(prefix) {
        return `export class ${this.getClassName(prefix)} {\n`;
    }
    indexValue() {
        throw new Error('Method not implemented.');
    }
    generateClass(prefix, stateVarName) {
        let res = '';
        const memberClassNames = [];
        for (let i = 0; i < this.members.length; i++) {
            const propertyClass = this.members[i][1].getClassName(prefix + '_StructField_' + this.members[i][0]);
            memberClassNames.push(propertyClass);
            res += this.members[i][1].generateClass(propertyClass, stateVarName);
        }
        res += this.classDef(prefix);
        res += this.generateProperties(memberClassNames);
        res += this.structConstructor(stateVarName, this.members.map((m, i) => [m[0], memberClassNames[i]]));
        res += '}\n';
        return res;
    }
    parseKeyFunc() {
        return `
        protected parseKey(key: void): Uint8Array {
            return new Uint8Array(0);
        }
        `;
    }
}
exports.ASTStruct = ASTStruct;
function getParamPrefix(item) {
    const contractName = getStrAfterLastColon(item.contract);
    if (isStringEmpty(contractName))
        return '';
    return contractName + '.' + item.label;
}
exports.getParamPrefix = getParamPrefix;
