export declare const AspectTmpl = "\nimport {\n    FilterTxCtx,\n    IAspectBlock,\n    IAspectTransaction,\n    IAspectOperation,\n    OnBlockFinalizeCtx,\n    OnBlockInitializeCtx,\n    PostContractCallCtx,\n    PostTxCommitCtx,\n    PostTxExecuteCtx,\n    PreContractCallCtx,\n    PreTxExecuteCtx,\n    OperationCtx,\n} from \"@artela/aspect-libs\";\n\n/**\n * There are two types of Aspect: Transaction-Level Aspect and Block-Level Aspect.\n * Transaction-Level Aspect will be triggered whenever there is a transaction calling the bound smart contract.\n * Block-Level Aspect will be triggered whenever there is a new block generated.\n *\n * An Aspect can be Transaction-Level, Block-Level,IAspectOperation or both.\n * You can implement corresponding interfaces: IAspectTransaction, IAspectBlock,IAspectOperation or both to tell Artela which\n * type of Aspect you are implementing.\n */\nexport class Aspect implements IAspectTransaction, IAspectBlock, IAspectOperation {\n    /**\n     * isOwner is the governance account implemented by the Aspect, when any of the governance operation\n     * (including upgrade, config, destroy) is made, isOwner method will be invoked to check\n     * against the initiator's account to make sure it has the permission.\n     *\n     * @param ctx context of Aspect state\n     * @param sender address of the operation initiator\n     * @return true if check success, false if check fail\n     */\n    isOwner(sender: string): bool {\n        // always return false on isOwner can make the Aspect immutable\n        return false;\n    }\n\n    /**\n     * onContractBinding is an Aspect lifecycle hook, it will be invoked by Aspect Core when\n     * a new smart contract is binding to this Aspect. Aspect can choose whether to allow the\n     * binding request or not. The binding request will succeed if onContractBinding returns true,\n     * otherwise it will fail.\n     *\n     * @param ctx context of Aspect state\n     * @param contractAddr address of the smart contract to binding with current Aspect\n     * @return true if binding succeed, otherwise false\n     */\n    onContractBinding(contractAddr: string): bool {\n        return true;\n    }\n\n\n    /**\n     * filterTx is a join-point which will be invoked when the mem pool first\n     * received the transaction. Since it is a join-point outside the consensus stage,\n     * so at this join-point, no state or context can be persisted.\n     *\n     * @param ctx context of the given join-point\n     * @return result of Aspect execution,if false drop tx in mempool\n     */\n    filterTx(ctx: FilterTxCtx): bool {\n        return true\n    }\n\n    /**\n     * preTxExecute is a join-point which will be invoked before the transaction execution.\n     *\n     * @param ctx context of the given join-point\n     * @return result of Aspect execution\n     */\n    preTxExecute(ctx: PreTxExecuteCtx): void {\n        // Implement me...\n    }\n\n    /**\n     * preContractCall is a join-point which will be invoked before the contract call is executed.\n     *\n     * @param ctx context of the given join-point\n     * @return result of Aspect execution\n     */\n    preContractCall(ctx: PreContractCallCtx): void {\n        // Implement me...\n    }\n\n    /**\n     * postContractCall is a join-point which will be invoked after a contract has finished.\n     *\n     * @param ctx context of the given join-point\n     * @return result of Aspect execution\n     */\n    postContractCall(ctx: PostContractCallCtx): void {\n        // Implement me...\n    }\n\n\n    /**\n     * postTxExecute is a join-point which will be invoked when the transaction execution is finished but state is not committed.\n     *\n     * @param ctx context of the given join-point\n     * @return result of Aspect execution\n     */\n    postTxExecute(ctx: PostTxExecuteCtx): void {\n        // Implement me...\n    }\n\n    /**\n     * onTxCommit is a join-point which will be invoked after the state of the transaction is committed.\n     *\n     * @param ctx context of the given join-point\n     * @return result of Aspect execution\n     */\n    postTxCommit(ctx: PostTxCommitCtx): void {\n        // Implement me...\n    }\n\n\n    /**\n     * onBlockFinalize is a join-point which will be invoked when a block proposal has been finalized.\n     *\n     * @param ctx context of the given join-point\n     * @return result of Aspect execution\n     */\n    onBlockFinalize(ctx: OnBlockFinalizeCtx): void {\n        // Implement me...\n    }\n\n\n    /**\n     * onBlockInitialize is a join-point which will be invoked when a new block proposal is prepared.\n     *\n     * @param ctx context of the given join-point\n     * @return result of Aspect execution\n     */\n    onBlockInitialize(ctx: OnBlockInitializeCtx): void {\n        // Implement me...\n    }\n\n\n    /**\n     * operation is a Aspect call.\n     *\n     * @param ctx  tx input\n     * @return result of operation execution\n     */\n    operation(ctx: OperationCtx, data: Uint8Array): Uint8Array{\n        // Implement me...\n        return new Uint8Array(0);\n    }\n}\n";
